

# 数据结构



## 三、数组、链表、跳表

数组-内存管理器-计算机在内存开辟了一段连续的地址，每一个地址，就直接可以通过内存管理器进行访问。

访问任何一个元素时间复杂度是一样的，也就是常数时间称为O(1)。



## 五、Hash table

哈希表(Hash table)，也叫散列表，是根据关键码值(Key value)而直接进行访问的数据结构。

它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。

这个映射函数叫做散列函数(Hash Function)，存放记录的数组叫作哈希表（或散列表）。

工程实践

- 电话号码簿
- 用户信息表
- 缓存（LRU Cache）
- 键值对存储（Redis）



四件套

1、clarification

2、possible solutions --> optimal ( time & space )

3、code

4、test cases



实战题目

实战题目1：有效的字母异位词(Anagram)等问题

题目解析：字母出现的次数都是一样的，但是顺序不一样

1、暴力，sort，sorted_str相等？ O(NlogN)

2、hash, map --> 统计每个字符的频次

第一单词计数加一，到了第二个单词计数减一，最后看map是否为空

用0~255[ASCII码最大的值就是0-255]，长度为256的数组来计数，相当于简化了的哈希表，只不过它的哈希函数的话就是它的ACSII码的值



实战题目2：字母异位词分组



实战题目3：两数之和

a, b --> a + b == target -->  for each a: check (target - a) exists in nums



3、一遍哈希表：在进行迭代并将元素插入到表的同时，我们还会回过头来检查表中是否已经存在当前元素对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。



## 六、树、二叉树、二叉搜索树

### 树

树节点的定义

为什么会出现树?



### 二叉树

子节点只有两个



数和图的最关键差别

有没有环，如果它这一个节点本身的话只链接到新的儿子结点，永远都不会走回去



图 Graph

Linked List 是特殊化的 Tree (因为有两个next指针)

Tree 是特殊化的 Graph (没有环的图就是树)



二叉树遍历

1、前序(Pre-order): 根-左-右

2、中序(In-order): 左-根-右

3、后序(Posr-order):左-右-根



二叉搜索树 Binary Search Tree

二叉搜索树，也称二叉排序树、有序二叉树（Ordered Binary Tree）、排序二叉树（Sorted Binary Tree），是指一棵空树或者具有下列性质的二叉树

1、左子树上所有结点的值均小于它的根节点的值

2、右子树上所有节点的值均大于它的根节点的值

3、以此类推：左、右子树也分别为二叉查找树。

中序遍历：升序排列



二叉搜索树常见操作

1、查询

2、插入新节点（创建）

3、删除

它的查询和插入都不再是O(n)了，它的查询和操作的化都是logn的，所以就相当于加速了。



### 堆Heap 和 二叉堆 Binary Heap

Heap: 可以迅速找到一堆数中的最大或者最小值的数据结构。

将根节点最大的堆叫做大顶堆或大根堆，根节点最小的堆叫做小顶堆或小根堆。常见的堆有二叉堆、斐波那契堆等。

假设是大顶堆，则常见操作（API）：

find-max: 				O(1)

delete-max: 			O(logN)

insert(create): 		O(logN) or O(1)



二叉堆性质

通过完全二叉堆来实现（注意：不是二叉搜索树）

二叉堆（大顶）它满足下列性质：

[性质一] 是一棵完全树

[性质二]树中任意节点的值总是>=其子节点的值



二叉堆实现细节

1、二叉堆一般都通过“数组”来实现

2、假设“第一个元素”在数组中的索引为0的化，则父节点和子节点的位置关系如下。

(01)索引为i的左孩子的索引是(2*i+1)

(02)索引为i的右孩子的索引是(2*i+2)

(03)索引为i的父节点的索引是floor((i-1)/2)



Insert插入操作 O(logN)

1、新元素一律先插入到堆的尾部

2、依次向上调整整个堆的结构（一直到根即可）

HeapifyUp



Delete Max 删除堆顶操作 O(logN)

1、将堆尾元素替换到顶部（即堆顶被替代删除掉）

2、依次从根部向下调整整个堆的结构（一直到堆尾即可）

HeapifyDown



注意：二叉堆是堆(优先队列priority_queue)的一种常见且简单的实现；但是并不是最优的实现。

- 堆的实现代码：[ https://shimo.im/docs/Lw86vJzOGOMpWZz2/](https://shimo.im/docs/Lw86vJzOGOMpWZz2/)



### 图

图的属性和分类

基于图相关的算法

图的属性

Graph(V,E)

V - vertex: 点

​	1、度 - 入度和出度

​	2、点与点之间：连通与否

E - edge: 边

​	1、有向和无向（单行线）

​	2、权重（边长）

图的表示和分类

​	图：无向无权图

​	图：有向无权图

​	图：无向有权图

​	图：有向有权图

基于图的常见算法

​		DFS

注：不要忘记加visited的集合，visited集合是必须的，和树的最大区别，树在做深度优先搜索的时候，可以不写，因为没有所谓的环路，也就是说访问它的点的话永远不会重复。图可能会重复，所以一定要有visited在这里。

​		BFS

# 七、递归

树的面试题解法一般都是递归

1、节点的定义

2、重复性（自相似性）



### 递归 Recursion

递归 - 循环

通过函数体来进行的循环



### JavaScript 递归

```
const recursion = (level, params) =>{
   // recursion terminator		递归终结条件
   if(level > MAX_LEVEL){
			process_result
			return
   }
   // process current level		处理当前层逻辑
   process(level, params)
   //drill down		下探到下一层
   recursion(level+1, params)		清理当前层
   //clean current level status if needed   
}
```

递归代码模版: https://shimo.im/docs/EICAr9lRPUIPHxsH/read



思维要点：

1、不要人肉进行递归（最大误区）

2、找到最近最简方法，将其拆解成可重复解决的问题（重复子问题）

3、数学归纳法思维



# 八、分治、回溯

### 分治 Divide & Conquer

```
const divide_conquer = (problem, params) => {
 // recursion terminator
 if (problem == null) {
  process_result
  return
 } 
 // process current problem
 subproblems = split_problem(problem, data)
 subresult1 = divide_conquer(subproblem[0], p1)
 subresult2 = divide_conquer(subproblem[1], p1)
 subresult3 = divide_conquer(subproblem[2], p1)
 ...
 // merge
 result = process_result(subresult1, subresult2, subresult3)
 // revert the current level status
}
```



分治代码模版: https://shimo.im/docs/zvlDqLLMFvcAF79A/read

### 回溯 Backtracking

回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程 中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将 取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问 题的答案。



回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种 情况:

• 找到一个可能存在的正确的答案;

• 在尝试了所有可能的分步方法后宣告该问题没有答案。 在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。



--总体来说：不断的在每一层去试就行了，你每一层有不同的办法，一个一个去试，看这个方法行不行，典型应用八皇后、数独。



# 九、深度优先搜索、广度优先搜索

遍历搜索

在树（图/状态集）中寻找特定结点



搜索-遍历

- 每个节点都要访问一次

- 每个节点仅仅要访问一次
- 对于节点的访问顺序不限
  - 深度优先: depth first search
  - 广度优先: Breadth first search
  - .... 优先级优先



### DFS - 深度优先

depth first search - 递归

#### 递归写法

```
//JavaScript
const visited = new Set()
const dfs = node => {
 if (visited.has(node)) return
 visited.add(node)
 dfs(node.left)
 dfs(node.right)
}
```



#### 非递归写法

手动模拟一个栈

不同语言: https://shimo.im/docs/UdY2UUKtliYXmk8t/read



### BFS - 广度优先

Breadth first search - 队列



维护一个queue

```
//JavaScript
const bfs = (root) => {
 let result = [], queue = [root]
 while (queue.length > 0) {
  let level = [], n = queue.length
	for (let i = 0; i < n; i++) {
   let node = queue.pop()
   level.push(node.val) 
   if (node.left) queue.unshift(node.left)
   if (node.right) queue.unshift(node.right)
  }
  result.push(level)
 }
 return result
};
```



不同语言: https://shimo.im/docs/ZBghMEZWix0Lc2jQ/read



# 十、贪心算法

贪心算法是一种在每一步选择中都采取在当前状态下最好或最优(即最有 利)的选择，从而希望导致结果是全局最好或最优的算法。



贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不 能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行 选择，有回退功能。



贪心：当下做局部最优判断

回溯：能够回退

动态规划：最优判断 + 回退



贪心法可以解决一些最优化问题，如:求图中的最小生成树、求哈夫曼编码 等。然而对于工程和生活中的问题，贪心法一般不能得到我们所要求的答案。



一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最 好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心 法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。



何种情况下用到贪心算法？

简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终 问题的最优解。这种子问题最优解称为最优子结构。



贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择， 不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前 进行选择，有回退功能。

# 十一、二分查找

### 二分查找的前提

1、目标函数单调性（单调递增或者单调递减）

2、存在上下界（bounded）

3、能够通过索引访问（index accessible）



代码模版

```
let left = 0, right = len(array) - 1
while (left <= right) {
 let mid = (left + right) >> 1
 if (array[mid] === target) { /*find the target*/; return }
 else if (array[mid] < target) left = mid + 1
 else right = mid - 1
}
```



# 十二、动态规划

分治 + 回溯 + 递归 + 动态规划





# 十三、字典树和并查集

### 字典树 - Trie

1、字典树的数据结构

​	基本结构：字典树，即Trie树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。

​	它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。

2、字典树的核心思想

​	Trie树的核心思想是空间换时间。

​	利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

3、字典树的基本性质

​	1、结点本身不存完整单词

​	2、从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串

​	3、每个结点的所有子结点路径代表的字符都不相同。



结点还可以存储额外信息



### 并查集

组团、配对问题

Group or not ?



基本操作

makeSet(s): 建立一个新的并查集，其中包含s个单元素集合。

unionSet(x, y): 把元素x和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并

find(x): 找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将它们各自的代表比较一下就可以了





# 十四、高级搜索

### 回顾搜索

​	1、朴素搜索

​	2、优化方式：不重复(fibonacci)、剪枝(生成括号问题)

​	3、搜索方向：

​				DFS: depth first search 深度优先搜索

​				BFS: breadth first search 广度优先搜索

​				双向搜索、启发式搜索



DFS 模版：https://shimo.im/docs/UdY2UUKtliYXmk8t/read

BFS 模版：https://shimo.im/docs/ZBghMEZWix0Lc2jQ/read

- [AlphaZero Explained](https://nikcheerla.github.io/deeplearningschool/2018/01/01/AlphaZero-Explained/)
- [棋类复杂度](https://en.wikipedia.org/wiki/Game_complexity)

回溯：试错思想，尝试分布去解决一个问题。

### 剪枝

### 双向BFS

### 启发式搜索(A*)

估价函数

启发式函数: h(n)，它用来评价哪些结点最有希望的是一个我们要找的结点，h(n)会返回一个非负实数，也可以认为是从结点n的目标结点路径的估计成本。



启发式函数是一种告知搜索方向的方法。它提供了一种明智的方法来猜测哪个邻居结点会导向一个目标。





# 十五、高级树、AVL和红黑树



保证性能的关键

1、保证二维维度 -> 左右子数结点平衡（recursively）

2、Balanced



AVL 树

1、发明者

2、Balance Factor（平衡因子）

​		是它的左子树的高度减去它右子树的高度（有时相反）。

​		balance factor = {-1, 0, 1}

3、通过旋转操作来进行平衡（四种）

​		1、左旋

​		2、右旋

​		3、左右旋

​		4、右左旋



AVL总结

1、平衡二叉搜索树

2、每个结点存balance factor = {-1, 0, 1}

3、四种旋转操作

不足：结点需要存储额外信息，且调整次数频繁



近似平衡二叉树

Red-black Tree

红黑树是一种近似平衡的二叉搜索树(Binary Search Tree)，它能够确保任何一个结点的左右子树的高度差小于两倍。具体来说，红黑树是满足如下条件的二叉搜索树

每个结点要么是红色，要么是黑色

根结点是黑色

每个叶结点（NIL结点，空结点）是黑色的。

不能有相邻接的两个红色结点

从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。



关键性质：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。



2-3 tree

AA tree

AVL tree

B tree









# 十六、位运算

### 位运算符

### 算数移位与逻辑移位

### 位运算的应用

​	为什么需要位运算？

​	机器里的数字表示方式和存储格式就是二进制

​	十进制和二进制如何相互转换 https://zh.wikihow.com/从十进制转换为二进制

​	4(d):0100

​	8(d):01000

​	5(d):0101

​	6(d):0110



位运算符

左移  													<<  			0011=> 0110

右移  													>> 			 0110 => 0011

按位或												｜				0011   1011  =>1011		只要有一个二进制位是1，那么或出来的结果就是1

按位与												 &				0011   1011  =>0011		只要有一个二进制位是0，那么与出来的结果就是0

按位取反										     ～			   0011   		   =>1100		0变成1，1变成0

按位异或(相同为零不同为一)			^			    0011   1011  =>1000		如果相异的话就是1，如果相同的话就是0



异或

异或:相同为 0，不同为 1。也可用“不进位加法”来理解。

异或操作的一些特点:
 x^0=x
 x^1s=~x //**注意** **1s = ~0**

x^(~x)=1s
x^x=0
c=a^b => a^c=b,b^c=a //交换两个数 

a^b^c=a^(b^c)=(a^b)^c //associative



指定位置的位运算

1. 将x最右边的n位清零:x&(~0<<n)

2. 获取x的第n位值(0或者1):(x>>n)&1

3. 获取x的第n位的幂值:x&(1<<n)

4. 仅将第n位置为1:x|(1<<n)

5. 仅将第n位置为0:x&(~(1<<n))

6. 将x最高位至第n位(含)清零:x&((1<<n)-1)



实战位运算要点

- 判断奇偶:
   x%2==1 —>(x&1)==1 x%2==0 —>(x&1)==0

- x>>1—>x/2.
   即: x=x/2; —> x=x>>1;

  mid=(left+right)/2; —> mid=(left+right)>>1;

- X=X&(X-1)清零最低位的1

- X&-X=>得到最低位的1

- X&~X=>0



### N 皇后位运算代码示例]

(https://shimo.im/docs/YzWa5ZZrZPYWahK2)

```
var totalNQueens = function(n) {
 let count = 0;
 void (function dfs(row = 0, cols = 0, xy_diff = 0, xy_sum = 0) {
	 if (row >= n) {
   count++;
   return;
  }
  // 皇后可以放的地方
  let bits = ~(cols | xy_diff | xy_sum) & ((1 << n) - 1);
  while (bits) {
   // 保留最低位的 1
   let p = bits & -bits;
   bits &= bits - 1;
   dfs(row + 1, cols | p, (xy_diff | p) << 1, (xy_sum | p) >> 1);
  }
 })();
 return count;
};
```





# 十七、布隆过滤器和LRU缓存

### 布隆过滤器 Bloom Filter

- [布隆过滤器的原理和实现](https://www.cnblogs.com/cpselvis/p/6265825.html)
- [使用布隆过滤器解决缓存击穿、垃圾邮件识别、集合判重](https://blog.csdn.net/tianyaleixiaowu/article/details/74721877)

- [布隆过滤器 Python 代码示例](https://shimo.im/docs/UITYMj1eK88JCJTH)
- [布隆过滤器 Python 实现示例](https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/)

- [高性能布隆过滤器 Python 实现示例](https://github.com/jhgg/pybloof)
- [布隆过滤器 Java 实现示例 1](https://github.com/lovasoa/bloomfilter/blob/master/src/main/java/BloomFilter.java)

- [布隆过滤器 Java 实现示例 2](https://github.com/Baqend/Orestes-Bloomfilter)



HashTable + 拉链存储重复元素

### Bloom Filter vs Hash Table

一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。

优点是空间效率和查询时间都远远超过一半的算法，

缺点是有一定的误识别率和删除困难。



### LRU Cache的实现、应用和题解

参考链接

- [Understanding the Meltdown exploit](https://www.sqlpassion.at/archive/2018/01/06/understanding-the-meltdown-exploit-in-my-own-simple-words/)
- [替换算法总揽](https://en.wikipedia.org/wiki/Cache_replacement_policies)
- [LRU Cache Python 代码示例](https://shimo.im/docs/CoyPAyXooGcDuLQo)



Cache 缓存

1、记忆

2、钱包 - 储物柜

3、代码模块



LRU Cache

两个要素：大小、替换策略

Hash Table + Double LinkedList

O(1)查询

O(1)修改、更新



LFU least frequently used

LRU least recently used













